 
--- C:\Projects\xrcon\xRcon\GameServerQuery.h --- 
#pragma once
#include <Windows.h>

#ifdef GAMESERVERQUERY_EXPORTS
#define GAMESERVERQUERY_API __declspec(dllexport)
#else
#define GAMESERVERQUERY_API __declspec(dllimport)
#endif

extern "C" GAMESERVERQUERY_API const char* ProcessGameServerCommand(
    int protocolId,
    bool raw,
    const char* ipOrHostname,
    int port,
    const char* command,
    const char* rconPassword
);

extern "C" GAMESERVERQUERY_API void FreeGameServerResponse(const char* response); 
--- C:\Projects\xrcon\xRcon\RconPage.h --- 
#pragma once
#include <Windows.h>
#include "ServerManager.h"

class RconPage {
public:
    static void handleRconPage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
private:
    static void sendRconCommand(HWND hwnd, const Server& server, const char* command);
}; 
--- C:\Projects\xrcon\xRcon\resource.h --- 
// resource.h
#define IDI_ICON1 101

 
--- C:\Projects\xrcon\xRcon\ServerManager.h --- 
#pragma once
#include <string>
#include <vector>
#include <Windows.h>
#include <map>

struct Server {
    std::string name;
    std::string ipOrHostname;
    int port = -1;
    std::string game;
    int protocolId = 0;
    std::string rconPassword;
    std::string gametypes; // Format: "id:humanreadable,id2:humanreadable2"
    std::string maps;      // Format: "id:humanreadable,id2:humanreadable2"
};

class ServerManager {
public:
    static std::vector<Server> loadServers();
    static void saveServer(const Server& server);
    static void deleteServer(const std::string& name);
    static std::vector<std::pair<std::string, int>> getGameOptions();
    static std::string getDefaultMaps(const std::string& game);
    static std::string getDefaultGametypes(const std::string& game);
    static bool validateIpOrHostname(const std::string& input);
    static bool validatePort(int port);
    static bool validateListFormat(const std::string& input);
    static bool validateServer(const Server& server);
    static void logDebug(const std::string& message);
    static std::map<std::string, std::string> parseList(const std::string& list); // Moved here
}; 
--- C:\Projects\xrcon\xRcon\ServerPage.h --- 
#pragma once
#include <Windows.h>
#include "ServerManager.h"


class ServerPage {
public:
    static void handleServerPage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static void editServer(HWND hwnd, int index);
}; 
--- C:\Projects\xrcon\xRcon\UIComponents.h --- 
#ifndef UICOMPONENTS_H
#define UICOMPONENTS_H

#include <windows.h>
#include <string>
#include "ServerManager.h"

class UIComponents {
public:
    static void createSidebar(HWND hwnd, HINSTANCE hInstance);
    static void createOutputBox(HWND hwnd, HINSTANCE hInstance);
    static void setOutputMessage(HWND hwnd, const char* message);
};

#endif 
--- C:\Projects\xrcon\xRcon\UIRcon.h --- 
#ifndef UIRCON_H
#define UIRCON_H

#include <windows.h>
#include <string>
#include <vector>
#include "ServerManager.h"

class UIRcon {
public:
    static void createRconPage(HWND hwnd, HINSTANCE hInstance);
    static void showRconPage(HWND hwnd);
    static void hideRconPage(HWND hwnd);
    static void updateServerSelector(HWND hwnd);
    static void updatePlayerTable(HWND hwnd, const Server& server);
    static void updateServerSettings(HWND hwnd, const Server& server);
    static void parseAndAddPlayer(HWND hwnd, std::string playerJson, int index, std::vector<std::wstring>& strings, bool isMOHAA, bool isMOHSHBT, bool isCOD);
private:
    static void scheduleRefresh(HWND hwnd, const Server& server);
};

#endif 
--- C:\Projects\xrcon\xRcon\UIServers.h --- 
#ifndef UISERVERS_H
#define UISERVERS_H

#include <windows.h>
#include "ServerManager.h"

class UIServers {
public:
    static void createServerTable(HWND hwnd, HINSTANCE hInstance);
    static void createServerForm(HWND hwnd, HINSTANCE hInstance);
    static void updateServerTable(HWND hwnd);
    static void createServerPage(HWND hwnd, HINSTANCE hInstance);
    static void showServerPage(HWND hwnd);
    static void hideServerPage(HWND hwnd);
};

#endif 
--- C:\Projects\xrcon\xRcon\main.cpp --- 
// --- xRcon\main.cpp ---
// Main entry point for the XRcon application.
// Sets up the Windows application, handles window messages, and manages UI page navigation.

#include <windows.h>
#include <commctrl.h>
#include "UIComponents.h"
#include "UIServers.h"
#include "UIRcon.h"
#include "ServerPage.h"
#include "RconPage.h"
#include "ServerManager.h"
#include "resource.h"

static HBRUSH g_hOutput = nullptr;        // Brush for output box background
static HBRUSH g_hFormBackground = nullptr; // Brush for form background

// Hides all controls for server and RCON pages.
void hideAllPageControls(HWND hwnd, bool showingServerPage) {
    // Hide server page controls
    ShowWindow(GetDlgItem(hwnd, 200), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 300), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 301), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 302), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 303), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 304), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 305), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 306), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 307), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 310), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 312), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 313), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 314), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 315), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 316), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 317), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 318), SW_HIDE);

    // Hide RCON page controls
    ShowWindow(GetDlgItem(hwnd, 500), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 501), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 502), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 503), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 504), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 510), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 511), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 512), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 513), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 514), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 515), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 516), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 517), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 518), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 519), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 520), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 521), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 522), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, 523), SW_HIDE);

    // Hide shared output box
    ShowWindow(GetDlgItem(hwnd, 400), SW_HIDE);
}

// Window procedure to handle messages for the main window.
LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    static bool isServerPage = true; // Tracks current page (true for server, false for RCON)

    switch (msg) {
    case WM_LBUTTONDOWN: {
        POINT pt = { LOWORD(lParam), HIWORD(lParam) }; // Get click coordinates
        HWND hitWnd = ChildWindowFromPoint(hwnd, pt);  // Find clicked control
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    case WM_CREATE: {
        // Initialize common controls for list views
        INITCOMMONCONTROLSEX icex = { sizeof(INITCOMMONCONTROLSEX), ICC_LISTVIEW_CLASSES | ICC_STANDARD_CLASSES };
        InitCommonControlsEx(&icex);

        // Create brushes for UI elements
        g_hOutput = CreateSolidBrush(RGB(0, 0, 0));
        g_hFormBackground = CreateSolidBrush(GetSysColor(COLOR_3DFACE));

        // Create UI components
        UIComponents::createSidebar(hwnd, (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE));
        UIServers::createServerPage(hwnd, (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE));
        UIRcon::createRconPage(hwnd, (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE));
        UIComponents::createOutputBox(hwnd, (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE));

        // Fallback: Set icons in WM_CREATE
        HICON hIcon = LoadIcon((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE), MAKEINTRESOURCE(IDI_ICON1));
        if (hIcon) {
            SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
            SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        }
        else {
            char error[256];
            sprintf_s(error, "Failed to load icon in WM_CREATE: %lu", GetLastError());
            ServerManager::logDebug(error);
        }

        // Show server page by default
        hideAllPageControls(hwnd, true);
        UIServers::showServerPage(hwnd);
        InvalidateRect(hwnd, nullptr, TRUE);
        UpdateWindow(hwnd);
        break;
    }

    case WM_ERASEBKGND: {
        HDC hdc = (HDC)wParam;
        RECT rect;
        GetClientRect(hwnd, &rect);
        FillRect(hdc, &rect, (HBRUSH)(COLOR_3DFACE + 1)); // Fill background
        return 1;
    }

    case WM_CTLCOLORSTATIC: {
        HDC hdc = (HDC)wParam;
        HWND hControl = (HWND)lParam;
        int ctrlId = GetDlgCtrlID(hControl);

        // Style output box (ID 400)
        if (ctrlId == 400) {
            SetBkColor(hdc, RGB(0, 0, 0));
            SetTextColor(hdc, RGB(255, 255, 255));
            return (LRESULT)g_hOutput;
        }

        // Style server form labels (IDs 312–318)
        if (ctrlId >= 312 && ctrlId <= 318) {
            SetBkMode(hdc, TRANSPARENT);
            SetTextColor(hdc, RGB(0, 0, 0));
            return (LRESULT)g_hFormBackground;
        }

        return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    case WM_COMMAND: {
        // Handle sidebar navigation
        if (LOWORD(wParam) == 100) { // Servers button
            if (!isServerPage) {
                isServerPage = true;
                hideAllPageControls(hwnd, true);
                UIServers::showServerPage(hwnd);
                // Ensure server table and form are on top
                SetWindowPos(GetDlgItem(hwnd, 200), HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
                SetWindowPos(GetDlgItem(hwnd, 310), HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
                InvalidateRect(hwnd, nullptr, TRUE);
                UpdateWindow(hwnd);
            }
        }
        else if (LOWORD(wParam) == 101) { // RCON button
            if (isServerPage) {
                isServerPage = false;
                hideAllPageControls(hwnd, false);
                UIRcon::showRconPage(hwnd);
                // Ensure player table and settings are on top
                SetWindowPos(GetDlgItem(hwnd, 501), HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
                SetWindowPos(GetDlgItem(hwnd, 504), HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
                InvalidateRect(hwnd, nullptr, TRUE);
                UpdateWindow(hwnd);
            }
        }

        // Delegate to page-specific handlers
        if (isServerPage) {
            ServerPage::handleServerPage(hwnd, msg, wParam, lParam);
        }
        else {
            RconPage::handleRconPage(hwnd, msg, wParam, lParam);
        }
        break;
    }

    case WM_NOTIFY: {
        LPNMHDR nmhdr = (LPNMHDR)lParam;
        // Handle notifications for server table (ID 200)
        if (nmhdr->idFrom == 200 && isServerPage) {
            ServerPage::handleServerPage(hwnd, msg, wParam, lParam);
        }
        // Handle notifications for player table (ID 501)
        else if (nmhdr->idFrom == 501 && !isServerPage) {
            RconPage::handleRconPage(hwnd, msg, wParam, lParam);
        }
        break;
    }

    case WM_TIMER: {
        // Handle timers for RCON page
        if (!isServerPage) {
            RconPage::handleRconPage(hwnd, msg, wParam, lParam);
        }
        break;
    }

    case WM_DESTROY: {
        // Clean up brushes
        if (g_hOutput) {
            DeleteObject(g_hOutput);
            g_hOutput = nullptr;
        }
        if (g_hFormBackground) {
            DeleteObject(g_hFormBackground);
            g_hFormBackground = nullptr;
        }
        PostQuitMessage(0); // Signal application exit
        break;
    }

    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return 0;
}

// Application entry point.
int WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nCmdShow) {
    // Register window class using WNDCLASSEX
    WNDCLASSEX wc = { 0 };
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.lpfnWndProc = WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L"RconApp";
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Load large icon (title bar)
    wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.hIconSm = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1)); // Load small icon (taskbar, Alt+Tab)

    // Log icon loading errors
    if (!wc.hIcon) {
        char error[256];
        sprintf_s(error, "Failed to load large icon: %lu", GetLastError());
        ServerManager::logDebug(error);
    }
    if (!wc.hIconSm) {
        char error[256];
        sprintf_s(error, "Failed to load small icon: %lu", GetLastError());
        ServerManager::logDebug(error);
    }

    if (!RegisterClassEx(&wc)) {
        char error[256];
        sprintf_s(error, "Failed to register window class: %lu", GetLastError());
        ServerManager::logDebug(error);
        return 0;
    }

    // Create main window
    HWND hwnd = CreateWindowEx(0, L"RconApp", L"XRcon", WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU,
        CW_USEDEFAULT, CW_USEDEFAULT, 1250, 650, nullptr, nullptr, hInstance, nullptr);

    if (!hwnd) {
        char error[256];
        sprintf_s(error, "Failed to create window: %lu", GetLastError());
        ServerManager::logDebug(error);
        return 0;
    }

    // Fallback: Set icons directly on the window
    HICON hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));
    if (hIcon) {
        SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);   // Large icon for title bar
        SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon); // Small icon for taskbar
    }
    else {
        char error[256];
        sprintf_s(error, "Failed to load icon for WM_SETICON: %lu", GetLastError());
        ServerManager::logDebug(error);
    }

    // Show and update window
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    // Message loop
    MSG msg;
    while (GetMessage(&msg, nullptr, 0, 0)) {
        if (!IsDialogMessage(hwnd, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return (int)msg.wParam;
} 
--- C:\Projects\xrcon\xRcon\RconPage.cpp --- 
ï»¿// --- xRcon\RconPage.cpp ---
// Implementation of the RCON page logic.
// Handles user interactions for sending RCON commands, updating server settings, and managing player actions.

#include "RconPage.h"
#include "UIRcon.h"
#include "UIComponents.h"
#include "GameServerQuery.h"
#include "ServerManager.h"
#include <commctrl.h>
#include <vector>
#include <sstream>
#include <string>
#include <map>

#pragma comment(lib, "comctl32.lib") // Link Common Controls library
#pragma comment(lib, "Ws2_32.lib")   // Link Winsock library
#pragma comment(lib, "GameServerQuery.lib") // Link GameServerQuery library

// Sends an RCON command to the specified server and displays the response.
void RconPage::sendRconCommand(HWND hwnd, const Server& server, const char* command) {
    if (server.ipOrHostname.empty() || server.port == 0) {
        UIComponents::setOutputMessage(hwnd, "Invalid server details: IP/hostname or port is invalid.");
        return;
    }

    // Construct full RCON command
    std::string fullCommand = std::string("rcon ") + command;
    const char* response = ProcessGameServerCommand(
        server.protocolId,
        false,
        server.ipOrHostname.c_str(),
        server.port,
        fullCommand.c_str(),
        server.rconPassword.empty() ? "" : server.rconPassword.c_str()
    );

    // Handle response or error
    if (!response || strncmp(response, "error=", 6) == 0) {
        std::string error = response ? response : "No response from server";
        UIComponents::setOutputMessage(hwnd, ("Command failed: " + error).c_str());
    }
    else {
        UIComponents::setOutputMessage(hwnd, response);
    }
    if (response) FreeGameServerResponse(response); // Free allocated response memory
}

// Handles messages for the RCON page, including commands, notifications, and timers.
void RconPage::handleRconPage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    if (msg == WM_COMMAND) {
        int id = LOWORD(wParam);
        if (id == 500 && HIWORD(wParam) == CBN_SELCHANGE) { // Server selection changed
            HWND hwndServerCombo = GetDlgItem(hwnd, 500);
            if (!hwndServerCombo) {
                UIComponents::setOutputMessage(hwnd, "Error: Server selector not available");
                return;
            }
            int index = static_cast<int>(SendMessage(hwndServerCombo, CB_GETCURSEL, 0, 0));
            if (index != CB_ERR) {
                auto servers = ServerManager::loadServers();
                if (index < static_cast<int>(servers.size())) {
                    UIRcon::updatePlayerTable(hwnd, servers[index]);
                    UIRcon::updateServerSettings(hwnd, servers[index]);
                }
            }
        }
        else if (id == 503) { // Send RCON command
            WCHAR buffer[1024];
            char ansiBuffer[1024];
            GetDlgItemTextW(hwnd, 502, buffer, sizeof(buffer) / sizeof(WCHAR));
            WideCharToMultiByte(CP_UTF8, 0, buffer, -1, ansiBuffer, sizeof(ansiBuffer), nullptr, nullptr);
            std::string command = ansiBuffer;
            if (command.empty()) {
                UIComponents::setOutputMessage(hwnd, "Error: Command cannot be empty");
                return;
            }

            HWND hwndServerCombo = GetDlgItem(hwnd, 500);
            if (!hwndServerCombo) {
                UIComponents::setOutputMessage(hwnd, "Error: Server selector not available");
                return;
            }
            int index = static_cast<int>(SendMessage(hwndServerCombo, CB_GETCURSEL, 0, 0));
            if (index == CB_ERR) {
                UIComponents::setOutputMessage(hwnd, "Error: No server selected");
                return;
            }

            auto servers = ServerManager::loadServers();
            if (index < static_cast<int>(servers.size())) {
                // Confirm sensitive commands
                if (command.find("kick") != std::string::npos || command.find("ban") != std::string::npos ||
                    command.find("rename") != std::string::npos || command.find("unbind") != std::string::npos) {
                    std::wstring confirmMsg = L"Are you sure you want to execute the command:\n" +
                        std::wstring(buffer) + L"?";
                    int result = MessageBoxW(hwnd, confirmMsg.c_str(), L"Confirm Action", MB_YESNO | MB_ICONWARNING);
                    if (result != IDYES) {
                        return;
                    }
                }
                sendRconCommand(hwnd, servers[index], ansiBuffer);
                // Update UI for player-affecting commands
                if (command.find("kick") != std::string::npos || command.find("ban") != std::string::npos ||
                    command.find("rename") != std::string::npos || command.find("unbind") != std::string::npos) {
                    UIRcon::updatePlayerTable(hwnd, servers[index]);
                    UIRcon::updateServerSettings(hwnd, servers[index]);
                }
            }
        }
        else if (id == 512) { // Apply hostname
            WCHAR buffer[1024];
            char ansiBuffer[1024];
            GetDlgItemTextW(hwnd, 511, buffer, sizeof(buffer) / sizeof(WCHAR));
            WideCharToMultiByte(CP_UTF8, 0, buffer, -1, ansiBuffer, sizeof(ansiBuffer), nullptr, nullptr);
            std::string hostname = ansiBuffer;
            if (hostname.empty()) {
                UIComponents::setOutputMessage(hwnd, "Error: Hostname cannot be empty");
                return;
            }

            HWND hwndServerCombo = GetDlgItem(hwnd, 500);
            if (!hwndServerCombo) {
                UIComponents::setOutputMessage(hwnd, "Error: Server not available");
                return;
            }
            int index = static_cast<int>(SendMessage(hwndServerCombo, CB_GETCURSEL, 0, 0));
            if (index == CB_ERR) {
                UIComponents::setOutputMessage(hwnd, "Error: No server selected");
                return;
            }

            auto servers = ServerManager::loadServers();
            if (index < static_cast<int>(servers.size())) {
                std::wstring confirmMsg = L"Are you sure you want to change the hostname to:\n" +
                    std::wstring(buffer) + L"?";
                int result = MessageBoxW(hwnd, confirmMsg.c_str(), L"Confirm Hostname Change", MB_YESNO | MB_ICONWARNING);
                if (result != IDYES) {
                    return;
                }
                std::string command = "sv_hostname \"" + hostname + "\"";
                sendRconCommand(hwnd, servers[index], command.c_str());
                UIRcon::updateServerSettings(hwnd, servers[index]);
            }
        }
        else if (id == 515) { // Apply map
            HWND hwndServerCombo = GetDlgItem(hwnd, 500);
            HWND hwndMapSelector = GetDlgItem(hwnd, 514);
            if (!hwndServerCombo || !hwndMapSelector) {
                UIComponents::setOutputMessage(hwnd, "Error: Server selector or map selector not available");
                return;
            }
            int serverIndex = static_cast<int>(SendMessage(hwndServerCombo, CB_GETCURSEL, 0, 0));
            int mapIndex = static_cast<int>(SendMessage(hwndMapSelector, CB_GETCURSEL, 0, 0));
            if (serverIndex == CB_ERR || mapIndex == CB_ERR) {
                UIComponents::setOutputMessage(hwnd, "Error: No server or map selected");
                return;
            }

            auto servers = ServerManager::loadServers();
            if (serverIndex < static_cast<int>(servers.size())) {
                std::map<std::string, std::string> mapList = ServerManager::parseList(servers[serverIndex].maps);
                auto it = mapList.begin();
                std::advance(it, mapIndex);
                std::string mapValue = it->first;
                std::wstring confirmMsg = L"Are you sure you want to change the map to:\n" +
                    std::wstring(it->second.begin(), it->second.end()) + L"?";
                int result = MessageBoxW(hwnd, confirmMsg.c_str(), L"Confirm Map Change", MB_YESNO | MB_ICONWARNING);
                if (result != IDYES) {
                    return;
                }
                std::string command = "map " + mapValue;
                sendRconCommand(hwnd, servers[serverIndex], command.c_str());
                UIRcon::updatePlayerTable(hwnd, servers[serverIndex]);
                UIRcon::updateServerSettings(hwnd, servers[serverIndex]);
            }
        }
        else if (id == 518) { // Apply gametype
            HWND hwndServerCombo = GetDlgItem(hwnd, 500);
            HWND hwndGametypeSelector = GetDlgItem(hwnd, 517);
            if (!hwndServerCombo || !hwndGametypeSelector) {
                UIComponents::setOutputMessage(hwnd, "Error: Server or gametype selector not available");
                return;
            }
            int serverIndex = static_cast<int>(SendMessage(hwndServerCombo, CB_GETCURSEL, 0, 0));
            int gametypeIndex = static_cast<int>(SendMessage(hwndGametypeSelector, CB_GETCURSEL, 0, 0));
            if (serverIndex == CB_ERR || gametypeIndex == CB_ERR) {
                UIComponents::setOutputMessage(hwnd, "Error: No server or gametype selected");
                return;
            }

            auto servers = ServerManager::loadServers();
            if (serverIndex < static_cast<int>(servers.size())) {
                bool isMOHAA = servers[serverIndex].game == "Medal of Honor: Allied Assault";
                std::map<std::string, std::string> gametypeList = ServerManager::parseList(servers[serverIndex].gametypes);
                auto it = gametypeList.begin();
                std::advance(it, gametypeIndex);
                std::string gametypeValue = it->first;
                std::wstring confirmMsg = L"Are you sure you want to change the gametype to:\n" +
                    std::wstring(it->second.begin(), it->second.end()) + L"?";
                int result = MessageBoxW(hwnd, confirmMsg.c_str(), L"Confirm Gametype Change", MB_YESNO | MB_ICONWARNING);
                if (result != IDYES) {
                    return;
                }
                std::string command = "g_gametype " + gametypeValue;
                sendRconCommand(hwnd, servers[serverIndex], command.c_str());
                if (isMOHAA) {
                    std::map<std::string, std::string> mapList = ServerManager::parseList(servers[serverIndex].maps);
                    int mapIndex = static_cast<int>(SendMessage(GetDlgItem(hwnd, 514), CB_GETCURSEL, 0, 0));
                    auto mapIt = mapList.begin();
                    std::advance(mapIt, mapIndex);
                    std::string mapCommand = "map " + mapIt->first;
                    sendRconCommand(hwnd, servers[serverIndex], mapCommand.c_str());
                }
                else {
                    sendRconCommand(hwnd, servers[serverIndex], "map_restart");
                }
                UIRcon::updatePlayerTable(hwnd, servers[serverIndex]);
                UIRcon::updateServerSettings(hwnd, servers[serverIndex]);
            }
        }
        else if (id == 521 || id == 522 || id == 523) { // Restart actions
            HWND hwndServerCombo = GetDlgItem(hwnd, 500);
            if (!hwndServerCombo) {
                UIComponents::setOutputMessage(hwnd, "Error: Server selector not available");
                return;
            }
            int index = static_cast<int>(SendMessage(hwndServerCombo, CB_GETCURSEL, 0, 0));
            if (index == CB_ERR) {
                UIComponents::setOutputMessage(hwnd, "Error: No server selected");
                return;
            }

            auto servers = ServerManager::loadServers();
            if (index < static_cast<int>(servers.size())) {
                std::string command;
                if (id == 521) {
                    bool isMOHAA = servers[index].game == "Medal of Honor: Allied Assault";
                    command = isMOHAA ? "restart" : "map_restart";
                }
                else if (id == 522) command = "fast_restart";
                else if (id == 523) command = "map_rotate";
                std::wstring confirmMsg = L"Are you sure you want to execute:\n" +
                    std::wstring(command.begin(), command.end()) + L"?";
                int result = MessageBoxW(hwnd, confirmMsg.c_str(), L"Confirm Action", MB_YESNO | MB_ICONWARNING);
                if (result != IDYES) {
                    return;
                }
                sendRconCommand(hwnd, servers[index], command.c_str());
                UIRcon::updatePlayerTable(hwnd, servers[index]);
                UIRcon::updateServerSettings(hwnd, servers[index]);
            }
        }
    }
    else if (msg == WM_NOTIFY) {
        LPNMHDR nmhdr = (LPNMHDR)lParam;
        if (nmhdr->idFrom == 501 && (nmhdr->code == NM_CLICK || nmhdr->code == NM_DBLCLK)) { // Player table click
            POINT pt;
            GetCursorPos(&pt);
            HWND playerTable = GetDlgItem(hwnd, 501);
            if (!playerTable) {
                return;
            }
            ScreenToClient(playerTable, &pt);
            LVHITTESTINFO hit = { 0 };
            hit.pt = pt;
            ListView_SubItemHitTest(playerTable, &hit);
            if (hit.iItem >= 0 && hit.iSubItem >= 5) {
                HWND hwndServerCombo = GetDlgItem(hwnd, 500);
                if (!hwndServerCombo) {
                    UIComponents::setOutputMessage(hwnd, "Error: Server selector not available");
                    return;
                }
                int index = static_cast<int>(SendMessage(hwndServerCombo, CB_GETCURSEL, 0, 0));
                if (index == CB_ERR) {
                    return;
                }
                auto servers = ServerManager::loadServers();
                if (index >= static_cast<int>(servers.size())) {
                    return;
                }
                const Server& server = servers[index];

                // Determine game-specific commands
                bool isMOHAA = server.game == "Medal of Honor: Allied Assault" || server.game == "Medal of Honor: AA Spearhead";
                bool isMOHSHBT = server.game == "Medal of Honor: AA Breakthrough";
                bool isCOD = server.game.find("Call of Duty") != std::string::npos;

                std::string command;
                WCHAR buffer[1024];
                char ansiNum[512];
                ListView_GetItemText(playerTable, hit.iItem, 0, buffer, sizeof(buffer) / sizeof(WCHAR));
                WideCharToMultiByte(CP_UTF8, 0, buffer, -1, ansiNum, sizeof(ansiNum), nullptr, nullptr);

                if (isMOHAA) {
                    if (hit.iSubItem == 5) command = "set namechange " + std::string(ansiNum);
                    else if (hit.iSubItem == 6) command = "set unbindplayer " + std::string(ansiNum);
                    else if (hit.iSubItem == 7) command = "clientkick " + std::string(ansiNum);
                }
                else if (isMOHSHBT && hit.iSubItem == 5) {
                    command = "clientkick " + std::string(ansiNum);
                }
                else if (isCOD) {
                    if (hit.iSubItem == 5) command = "clientkick " + std::string(ansiNum);
                    else if (hit.iSubItem == 6) command = "banclient " + std::string(ansiNum);
                }

                if (!command.empty()) {
                    std::wstring confirmMsg = L"Are you sure you want to execute:\n" +
                        std::wstring(command.begin(), command.end()) + L" on this player?";
                    int result = MessageBoxW(hwnd, confirmMsg.c_str(), L"Confirm action", MB_YESNO | MB_ICONWARNING);
                    if (result != IDYES) {
                        return;
                    }

                    sendRconCommand(hwnd, server, command.c_str());
                    UIRcon::updatePlayerTable(hwnd, server);
                    UIRcon::updateServerSettings(hwnd, server);
                }
            }
        }
    }
    else if (msg == WM_TIMER) {
        if (wParam == 1001) { // Refresh timer
            HWND hwndServerCombo = GetDlgItem(hwnd, 500);
            if (!hwndServerCombo) {
                UIComponents::setOutputMessage(hwnd, "Error: Server selector not available");
                return;
            }
            int index = static_cast<int>(SendMessage(hwndServerCombo, CB_GETCURSEL, 0, 0));
            if (index == CB_ERR) {
                UIComponents::setOutputMessage(hwnd, "No server selected for refresh");
                return;
            }
            auto servers = ServerManager::loadServers();
            if (index < static_cast<int>(servers.size())) {
                UIRcon::updatePlayerTable(hwnd, servers[index]);
                UIRcon::updateServerSettings(hwnd, servers[index]);
            }
            else {
                UIComponents::setOutputMessage(hwnd, "Error: Invalid server index");
            }
        }
    }
} 
--- C:\Projects\xrcon\xRcon\ServerManager.cpp --- 
// --- C:\Projects\xrcon\xRcon\ServerManager.cpp ---
// Implementation of server management functionality.
// Handles loading, saving, validating, and deleting game server configurations.

#include "ServerManager.h"
#include <fstream>
#include <sstream>
#include <algorithm>
#include <regex>
#include <ctime>

// Logs a debug message to debug.log with a timestamp.
void ServerManager::logDebug(const std::string& message) {
    std::ofstream logFile("debug.log", std::ios::app);
    if (logFile.is_open()) {
        std::time_t now = std::time(nullptr);
        char timeStr[26];
        ctime_s(timeStr, sizeof(timeStr), &now);
        timeStr[24] = '\0'; // Remove newline
        logFile << "[" << timeStr << "] " << message << "\n";
        logFile.close();
    }
}

// Validates an IP address or hostname.
bool ServerManager::validateIpOrHostname(const std::string& input) {
    if (input.empty()) {
        return false; // Empty input is invalid
    }

    // Validate IP address format
    std::regex ipRegex(R"(^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$)");
    std::smatch match;
    if (std::regex_match(input, match, ipRegex)) {
        for (size_t i = 1; i <= 4; ++i) {
            std::string segment = match[i].str();
            if (segment.size() > 1 && segment[0] == '0') {
                return false; // Leading zeros are invalid
            }
            try {
                size_t pos;
                int num = std::stoi(segment, &pos);
                if (pos != segment.size() || num < 0 || num > 255) {
                    return false; // Invalid segment
                }
            }
            catch (...) {
                return false; // Conversion error
            }
        }
        return true;
    }

    // Validate hostname format
    if (input.size() > 255) {
        return false; // Hostname too long
    }
    std::regex hostnameRegex(R"(^[a-zA-Z0-9][a-zA-Z0-9-]*(\.[a-zA-Z0-9][a-zA-Z0-9-]*)+$)");
    if (!std::regex_match(input, hostnameRegex)) {
        return false; // Invalid hostname format
    }
    if (input.find("..") != std::string::npos || input[0] == '-' || input[input.size() - 1] == '-') {
        return false; // Invalid characters or structure
    }
    return true;
}

// Validates a network port number.
bool ServerManager::validatePort(int port) {
    return port >= 1 && port <= 65535; // Valid port range
}

// Validates the format of a comma-separated key:value list.
bool ServerManager::validateListFormat(const std::string& input) {
    if (input.empty()) {
        return true; // Empty list is valid
    }
    std::stringstream ss(input);
    std::string pair;
    while (std::getline(ss, pair, ',')) {
        size_t pos = pair.find(':');
        if (pos == std::string::npos || pos == 0 || pos == pair.size() - 1) {
            return false; // Invalid pair format
        }
    }
    return true;
}

// Validates a server configuration.
bool ServerManager::validateServer(const Server& server) {
    // Trim whitespace from strings
    std::string name = server.name;
    name.erase(0, name.find_first_not_of(" \t\r\n"));
    name.erase(name.find_last_not_of(" \t\r\n") + 1);

    std::string ipOrHostname = server.ipOrHostname;
    ipOrHostname.erase(0, ipOrHostname.find_first_not_of(" \t\r\n"));
    ipOrHostname.erase(ipOrHostname.find_last_not_of(" \t\r\n") + 1);

    std::string gametypes = server.gametypes;
    gametypes.erase(0, gametypes.find_first_not_of(" \t\r\n"));
    gametypes.erase(gametypes.find_last_not_of(" \t\r\n") + 1);

    std::string maps = server.maps;
    maps.erase(0, maps.find_first_not_of(" \t\r\n"));
    maps.erase(maps.find_last_not_of(" \t\r\n") + 1);

    // Check all required fields
    return !name.empty() &&
        validateIpOrHostname(ipOrHostname) &&
        validatePort(server.port) &&
        validateListFormat(gametypes) &&
        validateListFormat(maps);
}

// Loads server configurations from servers.ini.
std::vector<Server> ServerManager::loadServers() {
    std::vector<Server> servers;
    std::ifstream file("servers.ini");
    std::string line, section;
    Server server;

    if (!file.is_open()) {
        return servers; // Return empty list if file cannot be opened
    }

    while (std::getline(file, line)) {
        if (line.empty()) continue;
        if (line[0] == '[' && line.back() == ']') {
            // Save previous server if valid
            if (!section.empty() && validateServer(server)) {
                servers.push_back(server);
            }
            section = line.substr(1, line.size() - 2);
            server = Server();
            server.name = section;
            continue;
        }
        size_t pos = line.find('=');
        if (pos == std::string::npos) continue;
        std::string key = line.substr(0, pos);
        std::string value = line.substr(pos + 1);
        // Assign server properties
        if (key == "ip") server.ipOrHostname = value;
        else if (key == "port") {
            try { server.port = std::stoi(value); }
            catch (...) { server.port = -1; }
        }
        else if (key == "game") server.game = value;
        else if (key == "protocol") {
            try { server.protocolId = std::stoi(value); }
            catch (...) { server.protocolId = 0; }
        }
        else if (key == "rconPassword") server.rconPassword = value;
        else if (key == "gametypes") server.gametypes = value;
        else if (key == "maps") server.maps = value;
    }
    // Save last server if valid
    if (!section.empty() && validateServer(server)) {
        servers.push_back(server);
    }
    file.close();
    return servers;
}

// Saves a server configuration to servers.ini.
void ServerManager::saveServer(const Server& server) {
    if (!validateServer(server)) {
        return; // Skip invalid server
    }
    std::vector<Server> servers = loadServers();
    // Remove server with same name
    servers.erase(std::remove_if(servers.begin(), servers.end(),
        [&server](const Server& s) { return s.name == server.name; }), servers.end());
    servers.push_back(server);

    // Write updated server list to file
    std::ofstream file("servers.ini");
    if (!file.is_open()) {
        return;
    }
    for (const auto& s : servers) {
        file << "[" << s.name << "]\n";
        file << "ip=" << s.ipOrHostname << "\n";
        file << "port=" << s.port << "\n";
        file << "game=" << s.game << "\n";
        file << "protocol=" << s.protocolId << "\n";
        file << "rconPassword=" << s.rconPassword << "\n";
        file << "gametypes=" << s.gametypes << "\n";
        file << "maps=" << s.maps << "\n\n";
    }
    file.close();
}

// Deletes a server configuration by name.
void ServerManager::deleteServer(const std::string& name) {
    std::vector<Server> servers = loadServers();
    // Remove server with matching name
    servers.erase(std::remove_if(servers.begin(), servers.end(),
        [&name](const Server& s) { return s.name == name; }), servers.end());

    // Write updated server list to file
    std::ofstream file("servers.ini");
    if (!file.is_open()) {
        return;
    }
    for (const auto& s : servers) {
        file << "[" << s.name << "]\n";
        file << "ip=" << s.ipOrHostname << "\n";
        file << "port=" << s.port << "\n";
        file << "game=" << s.game << "\n";
        file << "protocol=" << s.protocolId << "\n";
        file << "rconPassword=" << s.rconPassword << "\n";
        file << "gametypes=" << s.gametypes << "\n";
        file << "maps=" << s.maps << "\n\n";
    }
    file.close();
}

// Returns a list of supported games and their protocol IDs.
std::vector<std::pair<std::string, int>> ServerManager::getGameOptions() {
    return {
        {"Medal of Honor: Allied Assault", 1},
        {"Medal of Honor: AA Spearhead", 1},
        {"Medal of Honor: AA Breakthrough", 1},
        {"Call of Duty", 2},
        {"Call of Duty: United Offensive", 2},
        {"Call of Duty 2", 2},
        {"Call of Duty 4: Modern Warfare", 2},
        {"Call of Duty: World at War", 2}
    };
}

// Retrieves default maps for a game from default_maps.ini.
std::string ServerManager::getDefaultMaps(const std::string& game) {
    std::ifstream file("default_maps.ini");
    std::string line, section, maps;
    while (std::getline(file, line)) {
        if (line.empty()) continue;
        if (line[0] == '[' && line.back() == ']') {
            section = line.substr(1, line.size() - 2);
            continue;
        }
        if (section == game && line.find("maps=") == 0) {
            maps = line.substr(5);
            break;
        }
    }
    file.close();
    return maps;
}

// Retrieves default gametypes for a game from default_gametypes.ini.
std::string ServerManager::getDefaultGametypes(const std::string& game) {
    std::ifstream file("default_gametypes.ini");
    std::string line, section, gametypes;
    while (std::getline(file, line)) {
        if (line.empty()) continue;
        if (line[0] == '[' && line.back() == ']') {
            section = line.substr(1, line.size() - 2);
            continue;
        }
        if (section == game && line.find("gametypes=") == 0) {
            gametypes = line.substr(10);
            break;
        }
    }
    file.close();
    return gametypes;
}

// Parses a comma-separated key:value list into a map.
std::map<std::string, std::string> ServerManager::parseList(const std::string& list) {
    std::map<std::string, std::string> result;
    std::stringstream ss(list);
    std::string pair;
    while (std::getline(ss, pair, ',')) {
        size_t pos = pair.find(':');
        if (pos != std::string::npos && pos != 0 && pos != pair.size() - 1) {
            result[pair.substr(0, pos)] = pair.substr(pos + 1);
        }
    }
    return result;
} 
--- C:\Projects\xrcon\xRcon\ServerPage.cpp --- 
// --- xRcon\ServerPage.cpp ---
#include "ServerPage.h"
#include "UIServers.h"
#include "ServerManager.h"
#include "UIComponents.h"
#include "UIRcon.h"
#include <commctrl.h>
#include <regex>

// Declaration for hideAllPageControls from main.cpp
extern void hideAllPageControls(HWND hwnd, bool showingServerPage);

void ServerPage::handleServerPage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    static std::string editingServerName;
    if (msg == WM_COMMAND) {
        int id = LOWORD(wParam);
        if (id == 307) { // Save Server button
            WCHAR buffer[4096];
            char ansiBuffer[4096];
            Server server;

            GetDlgItemTextW(hwnd, 300, buffer, sizeof(buffer) / sizeof(WCHAR));
            WideCharToMultiByte(CP_UTF8, 0, buffer, -1, ansiBuffer, sizeof(ansiBuffer), nullptr, nullptr);
            server.name = ansiBuffer;
            server.name.erase(0, server.name.find_first_not_of(" \t\r\n"));
            server.name.erase(server.name.find_last_not_of(" \t\r\n") + 1);

            GetDlgItemTextW(hwnd, 301, buffer, sizeof(buffer) / sizeof(WCHAR));
            WideCharToMultiByte(CP_UTF8, 0, buffer, -1, ansiBuffer, sizeof(ansiBuffer), nullptr, nullptr);
            server.ipOrHostname = ansiBuffer;
            server.ipOrHostname.erase(0, server.ipOrHostname.find_first_not_of(" \t\r\n"));
            server.ipOrHostname.erase(server.ipOrHostname.find_last_not_of(" \t\r\n") + 1);

            GetDlgItemTextW(hwnd, 302, buffer, sizeof(buffer) / sizeof(WCHAR));
            try {
                server.port = std::stoi(std::wstring(buffer));
            }
            catch (...) {
                server.port = -1;
            }

            int gameIndex = static_cast<int>(SendDlgItemMessage(hwnd, 303, CB_GETCURSEL, 0, 0));
            auto games = ServerManager::getGameOptions();
            if (gameIndex >= 0 && gameIndex < static_cast<int>(games.size())) {
                server.game = games[gameIndex].first;
                server.protocolId = games[gameIndex].second;
            }
            else {
                UIComponents::setOutputMessage(hwnd, "Error: Invalid game selection");
                return;
            }

            GetDlgItemTextW(hwnd, 304, buffer, sizeof(buffer) / sizeof(WCHAR));
            WideCharToMultiByte(CP_UTF8, 0, buffer, -1, ansiBuffer, sizeof(ansiBuffer), nullptr, nullptr);
            server.rconPassword = ansiBuffer;
            server.rconPassword.erase(0, server.rconPassword.find_first_not_of(" \t\r\n"));
            server.rconPassword.erase(server.rconPassword.find_last_not_of(" \t\r\n") + 1);

            GetDlgItemTextW(hwnd, 305, buffer, sizeof(buffer) / sizeof(WCHAR));
            size_t wideLength = wcslen(buffer);
            WideCharToMultiByte(CP_UTF8, 0, buffer, -1, ansiBuffer, sizeof(ansiBuffer), nullptr, nullptr);
            if (wideLength >= 4096) {
                UIComponents::setOutputMessage(hwnd, "Error: Gametypes input exceeds 4096 characters");
                return;
            }
            WideCharToMultiByte(CP_UTF8, 0, buffer, -1, ansiBuffer, sizeof(ansiBuffer), nullptr, nullptr);
            server.gametypes = ansiBuffer;
            server.gametypes.erase(0, server.gametypes.find_first_not_of(" \t\r\n"));
            server.gametypes.erase(server.gametypes.find_last_not_of(" \t\r\n") + 1);

            GetDlgItemTextW(hwnd, 306, buffer, sizeof(buffer) / sizeof(WCHAR));
            wideLength = wcslen(buffer);
            WideCharToMultiByte(CP_UTF8, 0, buffer, -1, ansiBuffer, sizeof(ansiBuffer), nullptr, nullptr);
            if (wideLength >= 4096) {
                UIComponents::setOutputMessage(hwnd, "Error: Maps input exceeds 4096 characters");
                return;
            }
            WideCharToMultiByte(CP_UTF8, 0, buffer, -1, ansiBuffer, sizeof(ansiBuffer), nullptr, nullptr);
            server.maps = ansiBuffer;
            server.maps.erase(0, server.maps.find_first_not_of(" \t\r\n"));
            server.maps.erase(server.maps.find_last_not_of(" \t\r\n") + 1);

            if (server.name.empty()) {
                UIComponents::setOutputMessage(hwnd, "Error: Server name cannot be empty or whitespace");
                return;
            }
            if (!ServerManager::validateIpOrHostname(server.ipOrHostname)) {
                std::regex ipAttempt(R"(^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$)");
                std::string errorMsg = std::regex_match(server.ipOrHostname, ipAttempt)
                    ? "Error: Invalid IP address (use format: 192.168.0.1)"
                    : "Error: Invalid hostname (use format: example.com)";
                UIComponents::setOutputMessage(hwnd, errorMsg.c_str());
                return;
            }
            if (!ServerManager::validatePort(server.port)) {
                UIComponents::setOutputMessage(hwnd, "Error: Invalid port (1-65535)");
                return;
            }
            if (!ServerManager::validateListFormat(server.gametypes)) {
                UIComponents::setOutputMessage(hwnd, "Error: Invalid gametypes format (id:humanreadable,...)");
                return;
            }
            if (!ServerManager::validateListFormat(server.maps)) {
                UIComponents::setOutputMessage(hwnd, "Error: Invalid maps format (id:humanreadable,...)");
                return;
            }

            if (server.gametypes.empty()) {
                server.gametypes = ServerManager::getDefaultGametypes(server.game);
            }
            if (server.maps.empty()) {
                server.maps = ServerManager::getDefaultMaps(server.game);
            }

            if (!editingServerName.empty() && editingServerName != server.name) {
                ServerManager::deleteServer(editingServerName);
            }

            ServerManager::saveServer(server);
            UIServers::updateServerTable(hwnd);
            UIComponents::setOutputMessage(hwnd, "Server saved successfully");

            UIRcon::updateServerSelector(hwnd);

            // Clear the form
            SetDlgItemTextW(hwnd, 300, L"");
            SetDlgItemTextW(hwnd, 301, L"");
            SetDlgItemTextW(hwnd, 302, L"");
            SendDlgItemMessage(hwnd, 303, CB_SETCURSEL, 0, 0);
            SetDlgItemTextW(hwnd, 304, L"");
            SetDlgItemTextW(hwnd, 305, L"");
            SetDlgItemTextW(hwnd, 306, L"");
            editingServerName.clear();
            InvalidateRect(GetDlgItem(hwnd, 305), nullptr, TRUE);
            UpdateWindow(GetDlgItem(hwnd, 305));
            InvalidateRect(GetDlgItem(hwnd, 306), nullptr, TRUE);
            UpdateWindow(GetDlgItem(hwnd, 306));

            // Reset UI to show only Servers page controls
            hideAllPageControls(hwnd, true);
            UIServers::showServerPage(hwnd);
            ServerManager::logDebug("UI reset after saving server: " + server.name);
        }
    }
    else if (msg == WM_NOTIFY) {
        LPNMHDR nmhdr = (LPNMHDR)lParam;
        if (nmhdr->idFrom == 200 && (nmhdr->code == NM_CLICK || nmhdr->code == NM_DBLCLK)) {
            POINT pt;
            GetCursorPos(&pt);
            ScreenToClient(GetDlgItem(hwnd, 200), &pt);
            LVHITTESTINFO hit = { 0 };
            hit.pt = pt;
            ListView_SubItemHitTest(GetDlgItem(hwnd, 200), &hit);
            if (hit.iSubItem == 4 && hit.iItem >= 0) { // Edit column
                auto servers = ServerManager::loadServers();
                if (hit.iItem < static_cast<int>(servers.size())) {
                    editingServerName = servers[hit.iItem].name;
                    editServer(hwnd, hit.iItem);
                    UIComponents::setOutputMessage(hwnd, ("Editing server: " + editingServerName).c_str());
                }
            }
            else if (hit.iSubItem == 5 && hit.iItem >= 0) { // Delete column
                auto servers = ServerManager::loadServers();
                if (hit.iItem < static_cast<int>(servers.size())) {
                    ServerManager::deleteServer(servers[hit.iItem].name);
                    UIServers::updateServerTable(hwnd);
                    UIComponents::setOutputMessage(hwnd, "Server deleted successfully");

                    UIRcon::updateServerSelector(hwnd);

                    if (editingServerName == servers[hit.iItem].name) {
                        SetDlgItemTextW(hwnd, 300, L"");
                        SetDlgItemTextW(hwnd, 301, L"");
                        SetDlgItemTextW(hwnd, 302, L"");
                        SendDlgItemMessage(hwnd, 303, CB_SETCURSEL, 0, 0);
                        SetDlgItemTextW(hwnd, 304, L"");
                        SetDlgItemTextW(hwnd, 305, L"");
                        SetDlgItemTextW(hwnd, 306, L"");
                        editingServerName.clear();
                    }

                    // Reset UI to ensure only Servers page controls are visible
                    hideAllPageControls(hwnd, true);
                    UIServers::showServerPage(hwnd);
                    ServerManager::logDebug("UI reset after deleting server: " + servers[hit.iItem].name);
                }
            }
        }
    }
}

void ServerPage::editServer(HWND hwnd, int index) {
    auto servers = ServerManager::loadServers();
    if (index >= 0 && index < static_cast<int>(servers.size())) {
        const auto& server = servers[index];
        WCHAR buffer[4096];

        MultiByteToWideChar(CP_UTF8, 0, server.name.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
        SetDlgItemTextW(hwnd, 300, buffer);

        MultiByteToWideChar(CP_UTF8, 0, server.ipOrHostname.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
        SetDlgItemTextW(hwnd, 301, buffer);

        swprintf_s(buffer, L"%d", server.port);
        SetDlgItemTextW(hwnd, 302, buffer);

        auto games = ServerManager::getGameOptions();
        for (size_t i = 0; i < games.size(); ++i) {
            if (games[i].first == server.game) {
                SendDlgItemMessage(hwnd, 303, CB_SETCURSEL, i, 0);
                break;
            }
        }

        MultiByteToWideChar(CP_UTF8, 0, server.rconPassword.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
        SetDlgItemTextW(hwnd, 304, buffer);

        MultiByteToWideChar(CP_UTF8, 0, server.gametypes.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
        SetDlgItemTextW(hwnd, 305, buffer);

        MultiByteToWideChar(CP_UTF8, 0, server.maps.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
        SetDlgItemTextW(hwnd, 306, buffer);

        InvalidateRect(GetDlgItem(hwnd, 305), nullptr, TRUE);
        UpdateWindow(GetDlgItem(hwnd, 305));
        InvalidateRect(GetDlgItem(hwnd, 306), nullptr, TRUE);
        UpdateWindow(GetDlgItem(hwnd, 306));
    }
} 
--- C:\Projects\xrcon\xRcon\UIComponents.cpp --- 
// --- xRcon\UIComponents.cpp ---
// Implementation of common UI components for the application.
// Provides functionality to create a sidebar with navigation buttons and an output box for messages.

#include "UIComponents.h"
#include <commctrl.h>

#pragma comment(lib, "comctl32.lib") // Link Common Controls library

// Static UI control handle
static HWND outputBox = nullptr; // Edit box for displaying output messages

// Creates the sidebar with navigation buttons and version label.
void UIComponents::createSidebar(HWND hwnd, HINSTANCE hInstance) {
    // Create "Servers" navigation button
    CreateWindow(L"BUTTON", L"Servers", WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
        15, 15, 120, 120, hwnd, (HMENU)100, hInstance, nullptr);

    // Create "RCON" navigation button
    CreateWindow(L"BUTTON", L"RCON", WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
        15, 145, 120, 120, hwnd, (HMENU)101, hInstance, nullptr);

    CreateWindow(L"STATIC", L"Medal of Honor and Spearhead require a custom server side script to use the Rename and Unbind functions, these are included in the program directory ", WS_CHILD | WS_VISIBLE,
        800, 490, 400, 80, hwnd, (HMENU)104, hInstance, nullptr);



    // Create version label
    CreateWindow(L"STATIC", L"Version:0.05", WS_CHILD | WS_VISIBLE,
        1145, 590, 100, 20, hwnd, (HMENU)103, hInstance, nullptr);
}

// Creates the output box for displaying messages.
void UIComponents::createOutputBox(HWND hwnd, HINSTANCE hInstance) {
    // Create multiline, read-only edit box with scrollbars
    outputBox = CreateWindow(L"EDIT", L"",
        WS_CHILD | WS_VISIBLE | WS_BORDER | ES_MULTILINE | ES_AUTOVSCROLL | ES_READONLY | WS_VSCROLL,
        160, 495, 600, 100, hwnd, (HMENU)400, hInstance, nullptr);

    if (outputBox) {
        SendMessage(outputBox, EM_SETLIMITTEXT, 32768, 0); // Set text limit to 32KB
    }
}

// Sets the message displayed in the output box.
void UIComponents::setOutputMessage(HWND hwnd, const char* message) {
    HWND hwndOutputBox = GetDlgItem(hwnd, 400); // Get output box handle
    if (hwndOutputBox) {
        WCHAR buffer[4096];
        // Convert UTF-8 message to wide string
        MultiByteToWideChar(CP_UTF8, 0, message, -1, buffer, sizeof(buffer) / sizeof(WCHAR));
        SendMessage(hwndOutputBox, WM_SETTEXT, 0, (LPARAM)buffer); // Set message text
    }
} 
--- C:\Projects\xrcon\xRcon\UIRcon.cpp --- 
// --- xRcon\UIRcon.cpp ---
// Implementation of the RCON (Remote Console) UI for managing game servers.
// Provides functionality to create and manage a UI page for server selection, player information, and server settings.

#include "UIRcon.h"
#include "UIComponents.h"
#include "GameServerQuery.h"
#include "ServerManager.h"
#include <commctrl.h>
#include <vector>
#include <sstream>
#include <string>

#pragma comment(lib, "comctl32.lib") // Link Common Controls library
#pragma comment(lib, "Ws2_32.lib")   // Link Winsock library
#pragma comment(lib, "GameServerQuery.lib") // Link GameServerQuery library

// Static UI control handles
static HWND playerTable = nullptr;       // List view for player information
static HWND serverCombo = nullptr;       // Combo box for server selection
static HWND commandInput = nullptr;      // Edit box for RCON commands
static HWND serverInfoStatic = nullptr;  // Group box for server settings
static HWND sendButton = nullptr;        // Button to send RCON commands
static HWND hostnameInput = nullptr;     // Edit box for server hostname
static HWND hostnameApply = nullptr;     // Button to apply hostname changes
static HWND mapSelector = nullptr;       // Combo box for map selection
static HWND mapApply = nullptr;          // Button to apply map changes
static HWND gametypeSelector = nullptr;  // Combo box for gametype selection
static HWND gametypeApply = nullptr;     // Button to apply gametype changes
static HWND playersLabel = nullptr;      // Label for player count
static HWND restartButton = nullptr;     // Button for server restart
static HWND fastRestartButton = nullptr; // Button for fast server restart
static HWND mapRotateButton = nullptr;   // Button for map rotation
static bool rconPageCreated = false;     // Flag to track if RCON page is created
static const UINT_PTR REFRESH_TIMER_ID = 1001; // Timer ID for periodic refresh
static std::vector<WCHAR*> mapData;      // Stores map names for combo box
static std::vector<WCHAR*> gametypeData; // Stores gametype names for combo box
static std::string lastGame;             // Tracks last game type for column preservation

// Creates the RCON UI page with controls for server management.
void UIRcon::createRconPage(HWND hwnd, HINSTANCE hInstance) {
    if (rconPageCreated) {
        return; // Prevent multiple creations
    }

    // Create server selection combo box
    serverCombo = CreateWindow(WC_COMBOBOX, L"", WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST | WS_VSCROLL,
        160, 10, 600, 200, hwnd, (HMENU)500, hInstance, nullptr);

    // Create player table (list view)
    playerTable = CreateWindow(WC_LISTVIEW, L"", WS_CHILD | WS_VISIBLE | LVS_REPORT | LVS_SINGLESEL | WS_TABSTOP,
        160, 50, 600, 400, hwnd, (HMENU)501, hInstance, nullptr);
    if (playerTable) {
        // Enable full row selection, grid lines, and header drag-drop
        ListView_SetExtendedListViewStyle(playerTable, LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_HEADERDRAGDROP);
        EnableWindow(playerTable, TRUE);
    }

    // Initialize player table columns
    LVCOLUMN col = { 0 };
    col.mask = LVCF_TEXT | LVCF_WIDTH;
    WCHAR headers[][20] = { L"Num", L"Name", L"IP", L"Score", L"Ping" };
    int widths[] = { 40, 140, 140, 45, 45 };
    for (int i = 0; i < 5; ++i) {
        col.cx = widths[i];
        col.pszText = headers[i];
        if (playerTable) {
            ListView_InsertColumn(playerTable, i, &col);
        }
    }

    // Create server settings group box
    serverInfoStatic = CreateWindow(L"BUTTON", L"Server Settings", WS_CHILD | WS_VISIBLE | BS_GROUPBOX,
        790, 10, 440, 440, hwnd, (HMENU)504, hInstance, nullptr);

    // Layout coordinates for server settings controls
    int x = 820, y = 40, w = 380, h = 25;

    // Create hostname controls
    CreateWindow(L"STATIC", L"Hostname:", WS_CHILD, x, y + 4, 100, h, hwnd, (HMENU)510, hInstance, nullptr);
    hostnameInput = CreateWindow(L"EDIT", L"", WS_CHILD | WS_BORDER | ES_AUTOHSCROLL,
        x + 110, y, w - 190, h, hwnd, (HMENU)511, hInstance, nullptr);
    hostnameApply = CreateWindow(L"BUTTON", L"Apply", WS_CHILD | BS_PUSHBUTTON,
        x + w - 70, y, 70, h, hwnd, (HMENU)512, hInstance, nullptr);
    y += 40;

    // Create map selection controls
    CreateWindow(L"STATIC", L"Map:", WS_CHILD, x, y + 4, 100, h, hwnd, (HMENU)513, hInstance, nullptr);
    mapSelector = CreateWindow(WC_COMBOBOX, L"", WS_CHILD | CBS_DROPDOWNLIST | WS_VSCROLL,
        x + 110, y, w - 190, 200, hwnd, (HMENU)514, hInstance, nullptr);
    mapApply = CreateWindow(L"BUTTON", L"Apply", WS_CHILD | BS_PUSHBUTTON,
        x + w - 70, y, 70, h, hwnd, (HMENU)515, hInstance, nullptr);
    y += 40;

    // Create gametype selection controls
    CreateWindow(L"STATIC", L"Gametype:", WS_CHILD, x, y + 4, 100, h, hwnd, (HMENU)516, hInstance, nullptr);
    gametypeSelector = CreateWindow(WC_COMBOBOX, L"", WS_CHILD | CBS_DROPDOWNLIST | WS_VSCROLL,
        x + 110, y, w - 190, 200, hwnd, (HMENU)517, hInstance, nullptr);
    gametypeApply = CreateWindow(L"BUTTON", L"Apply", WS_CHILD | BS_PUSHBUTTON,
        x + w - 70, y, 70, h, hwnd, (HMENU)518, hInstance, nullptr);
    y += 40;

    // Create player count label
    CreateWindow(L"STATIC", L"Players:", WS_CHILD, x, y + 4, 100, h, hwnd, (HMENU)519, hInstance, nullptr);
    playersLabel = CreateWindow(L"STATIC", L"0/0", WS_CHILD, x + 110, y + 4, 100, h, hwnd, (HMENU)520, hInstance, nullptr);
    y += 40;

    // Create server action buttons
    restartButton = CreateWindow(L"BUTTON", L"Restart", WS_CHILD | BS_PUSHBUTTON,
        x, y, 100, h, hwnd, (HMENU)521, hInstance, nullptr);
    fastRestartButton = CreateWindow(L"BUTTON", L"Fast Restart", WS_CHILD | BS_PUSHBUTTON,
        x + 110, y, 100, h, hwnd, (HMENU)522, hInstance, nullptr);
    mapRotateButton = CreateWindow(L"BUTTON", L"Map Rotate", WS_CHILD | BS_PUSHBUTTON,
        x + 220, y, 100, h, hwnd, (HMENU)523, hInstance, nullptr);

    // Create RCON command input
    commandInput = CreateWindow(L"EDIT", L"", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL,
        160, 460, 475, 25, hwnd, (HMENU)502, hInstance, nullptr);
    if (commandInput) {
        SendMessage(commandInput, EM_SETLIMITTEXT, 1024, 0); // Limit input to 1024 characters
    }

    // Create send command button
    sendButton = CreateWindow(L"BUTTON", L"Send Command", WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
        640, 460, 120, 25, hwnd, (HMENU)503, hInstance, nullptr);

    rconPageCreated = true;
    SetTimer(hwnd, REFRESH_TIMER_ID, 60000, nullptr); // Start 60-second refresh timer
    updateServerSelector(hwnd); // Populate server list
}

// Shows the RCON page by making all controls visible.
void UIRcon::showRconPage(HWND hwnd) {
    if (!rconPageCreated) {
        createRconPage(hwnd, (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE)); // Create page if not exists
    }

    // Show all controls
    ShowWindow(GetDlgItem(hwnd, 500), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 501), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 502), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 503), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 504), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 510), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 511), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 512), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 513), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 514), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 515), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 516), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 517), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 518), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 519), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 520), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 521), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 522), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 523), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 400), SW_SHOW); // Unknown control (possibly parent or output)

    // Ensure player table is focused and on top
    SetWindowPos(GetDlgItem(hwnd, 501), HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
    EnableWindow(GetDlgItem(hwnd, 501), TRUE);
    SetFocus(GetDlgItem(hwnd, 501));

    updateServerSelector(hwnd); // Refresh server list
    InvalidateRect(hwnd, nullptr, TRUE); // Redraw window

    // Update selected server's player table and settings
    HWND hwndServerCombo = GetDlgItem(hwnd, 500);
    if (hwndServerCombo) {
        int index = static_cast<int>(SendMessage(hwndServerCombo, CB_GETCURSEL, 0, 0));
        if (index != CB_ERR) {
            auto servers = ServerManager::loadServers();
            if (index < static_cast<int>(servers.size())) {
                UIRcon::updatePlayerTable(hwnd, servers[index]);
                UIRcon::updateServerSettings(hwnd, servers[index]);
            }
        }
    }
}

// Hides the RCON page by stopping the refresh timer.
void UIRcon::hideRconPage(HWND hwnd) {
    if (rconPageCreated) {
        KillTimer(hwnd, REFRESH_TIMER_ID); // Stop refresh timer
    }
}

// Updates the server selection combo box with available servers.
void UIRcon::updateServerSelector(HWND hwnd) {
    HWND hwndServerCombo = GetDlgItem(hwnd, 500);
    if (!hwndServerCombo) {
        return; // Combo box not found
    }

    SendMessage(hwndServerCombo, CB_RESETCONTENT, 0, 0); // Clear existing items
    auto servers = ServerManager::loadServers(); // Load server list

    std::vector<std::wstring> serverNames;
    for (const auto& server : servers) {
        if (server.name.empty()) {
            continue; // Skip servers with empty names
        }
        WCHAR buffer[4096];
        int len = MultiByteToWideChar(CP_UTF8, 0, server.name.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
        if (len == 0) {
            continue; // Skip if conversion fails
        }
        serverNames.emplace_back(buffer);
        SendMessage(hwndServerCombo, CB_ADDSTRING, 0, (LPARAM)serverNames.back().c_str());
    }

    if (!servers.empty()) {
        SendMessage(hwndServerCombo, CB_SETCURSEL, 0, 0); // Select first server
        updatePlayerTable(hwnd, servers[0]); // Update player table
        updateServerSettings(hwnd, servers[0]); // Update server settings
        EnableWindow(GetDlgItem(hwnd, 503), TRUE); // Enable send button
    }
    else {
        ListView_DeleteAllItems(GetDlgItem(hwnd, 501)); // Clear player table
        EnableWindow(GetDlgItem(hwnd, 503), TRUE); // Disable send button
        for (int id = 510; id <= 523; ++id) {
            EnableWindow(GetDlgItem(hwnd, id), TRUE); // Disable settings controls
        }
    }
    InvalidateRect(hwndServerCombo, nullptr, TRUE); // Redraw combo box
    UpdateWindow(hwndServerCombo);
}

// Schedules a refresh of server data using a timer.
void UIRcon::scheduleRefresh(HWND hwnd, const Server& server) {
    SetTimer(hwnd, REFRESH_TIMER_ID, 60000, nullptr); // Set 60-second timer
}

// Updates server settings controls (hostname, map, gametype, players).
void UIRcon::updateServerSettings(HWND hwnd, const Server& server) {
    // Get control handles
    HWND hwndHostnameInput = GetDlgItem(hwnd, 511);
    HWND hwndMapSelector = GetDlgItem(hwnd, 514);
    HWND hwndGametypeSelector = GetDlgItem(hwnd, 517);
    HWND hwndPlayersLabel = GetDlgItem(hwnd, 520);

    if (!hwndHostnameInput || !hwndMapSelector || !hwndGametypeSelector || !hwndPlayersLabel) {
        scheduleRefresh(hwnd, server); // Retry later if controls are missing
        return;
    }

    // Determine game type for conditional logic
    bool isMOHAA = server.game == "Medal of Honor: Allied Assault";
    bool isMOHSHBT = server.game == "Medal of Honor: AA Spearhead" || server.game == "Medal of Honor: AA Breakthrough";
    bool isCOD = server.game.find("Call of Duty") != std::string::npos;
    bool isCOD2Plus = server.game == "Call of Duty 2" || server.game == "Call of Duty 4: Modern Warfare" || server.game == "Call of Duty: World at War";

    // Show/hide action buttons based on game type
    ShowWindow(GetDlgItem(hwnd, 521), isMOHAA || isMOHSHBT || isCOD ? SW_SHOW : SW_HIDE); // Restart
    ShowWindow(GetDlgItem(hwnd, 522), isCOD2Plus ? SW_SHOW : SW_HIDE); // Fast Restart
    ShowWindow(GetDlgItem(hwnd, 523), isCOD && !isMOHAA && !isMOHSHBT ? SW_SHOW : SW_HIDE); // Map Rotate

    // Query server status
    const char* response = ProcessGameServerCommand(
        server.protocolId,
        false,
        server.ipOrHostname.c_str(),
        server.port,
        "getstatus",
        ""
    );

    if (!response || strncmp(response, "error=", 6) == 0) {
        std::string error = response ? response : "No response from server";
        UIComponents::setOutputMessage(hwnd, ("Failed to fetch server status: " + error).c_str());
        if (response) FreeGameServerResponse(response);
        scheduleRefresh(hwnd, server);
        return;
    }

    std::string json = response;
    FreeGameServerResponse(response);

    // Helper to extract JSON fields
    auto extractField = [](const std::string& json, const std::string& field) {
        size_t pos = json.find("\"" + field + "\":");
        if (pos == std::string::npos) return std::string();
        pos += field.length() + 3;
        if (json[pos] == '"') {
            pos++;
            size_t end = json.find('"', pos);
            return json.substr(pos, end - pos);
        }
        else {
            size_t end = json.find_first_of(",}", pos);
            return json.substr(pos, end - pos);
        }
        };

    // Extract server information
    std::string hostname = extractField(json, "sv_hostname");
    std::string mapname = extractField(json, "mapname");
    std::string gametype = extractField(json, isMOHAA ? "g_gametypestring" : "g_gametype");
    std::string maxclients = extractField(json, "sv_maxclients");
    size_t playerCount = 0;
    size_t playersPos = json.find("\"players\":");
    if (playersPos != std::string::npos) {
        std::string playersJson = json.substr(playersPos + 10);
        if (playersJson != "[]") {
            for (size_t i = 0; i < playersJson.length(); ++i) {
                if (playersJson[i] == '{') ++playerCount; // Count player objects
            }
        }
    }

    // Update hostname input
    WCHAR buffer[4096];
    MultiByteToWideChar(CP_UTF8, 0, hostname.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
    SetWindowTextW(hwndHostnameInput, buffer);

    // Clear existing map and gametype data
    for (WCHAR* ptr : mapData) free(ptr);
    for (WCHAR* ptr : gametypeData) free(ptr);
    mapData.clear();
    gametypeData.clear();

    // Populate map selector
    SendMessage(hwndMapSelector, CB_RESETCONTENT, 0, 0);
    std::map<std::string, std::string> mapList = ServerManager::parseList(server.maps);
    int selectedMapIndex = -1, index = 0;
    for (const auto& pair : mapList) {
        MultiByteToWideChar(CP_UTF8, 0, pair.second.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
        SendMessage(hwndMapSelector, CB_ADDSTRING, 0, (LPARAM)buffer);
        WCHAR* data = _wcsdup(buffer);
        SendMessage(hwndMapSelector, CB_SETITEMDATA, index, (LPARAM)data);
        mapData.push_back(data);
        if (pair.first == mapname) selectedMapIndex = index;
        ++index;
    }
    if (selectedMapIndex >= 0) {
        SendMessage(hwndMapSelector, CB_SETCURSEL, selectedMapIndex, 0);
    }

    // Populate gametype selector
    SendMessage(hwndGametypeSelector, CB_RESETCONTENT, 0, 0);
    std::map<std::string, std::string> gametypeList = ServerManager::parseList(server.gametypes);
    int selectedGametypeIndex = -1;
    index = 0;
    for (const auto& pair : gametypeList) {
        MultiByteToWideChar(CP_UTF8, 0, pair.second.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
        SendMessage(hwndGametypeSelector, CB_ADDSTRING, 0, (LPARAM)buffer);
        WCHAR* data = _wcsdup(buffer);
        SendMessage(hwndGametypeSelector, CB_SETITEMDATA, index, (LPARAM)data);
        gametypeData.push_back(data);
        if (pair.first == gametype || (isMOHAA && pair.second == gametype)) selectedGametypeIndex = index;
        ++index;
    }
    if (selectedGametypeIndex >= 0) {
        SendMessage(hwndGametypeSelector, CB_SETCURSEL, selectedGametypeIndex, 0);
    }

    // Update player count label
    std::string playersText = std::to_string(playerCount) + "/" + maxclients;
    MultiByteToWideChar(CP_UTF8, 0, playersText.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
    SetWindowTextW(hwndPlayersLabel, buffer);

    scheduleRefresh(hwnd, server); // Schedule next refresh
}

// Updates the player table with current server player data.
void UIRcon::updatePlayerTable(HWND hwnd, const Server& server) {
    Sleep(500); // Brief delay to handle server response timing
    HWND hwndPlayerTable = GetDlgItem(hwnd, 501);
    if (!hwndPlayerTable) {
        return; // Player table not found
    }

    // Recreate columns if game type changes
    if (lastGame != server.game) {
        ListView_DeleteAllItems(hwndPlayerTable);
        while (ListView_DeleteColumn(hwndPlayerTable, 0)) {}
        LVCOLUMN col = { 0 };
        col.mask = LVCF_TEXT | LVCF_WIDTH;
        WCHAR headers[][20] = { L"Num", L"Name", L"IP", L"Score", L"Ping" };
        int widths[] = { 40, 140, 140, 45, 45 };
        int colCount = 5;
        for (int i = 0; i < 5; ++i) {
            col.cx = widths[i];
            col.pszText = headers[i];
            ListView_InsertColumn(hwndPlayerTable, i, &col);
        }

        // Add game-specific action columns
        WCHAR renameText[] = L"Rename";
        WCHAR unbindText[] = L"Unbind";
        WCHAR kickText[] = L"Kick";
        WCHAR banText[] = L"Ban";
        bool isMOHAA = server.game == "Medal of Honor: Allied Assault" || server.game == "Medal of Honor: AA Spearhead";
        bool isMOHSHBT = server.game == "Medal of Honor: AA Breakthrough";
        bool isCOD = server.game.find("Call of Duty") != std::string::npos;

        if (isMOHAA) {
            int actionWidths[] = { 60, 60, 60 };
            col.cx = actionWidths[0]; col.pszText = renameText; ListView_InsertColumn(hwndPlayerTable, colCount++, &col);
            col.cx = actionWidths[1]; col.pszText = unbindText; ListView_InsertColumn(hwndPlayerTable, colCount++, &col);
            col.cx = actionWidths[2]; col.pszText = kickText; ListView_InsertColumn(hwndPlayerTable, colCount++, &col);
        }
        else if (isMOHSHBT) {
            col.cx = 80; col.pszText = kickText; ListView_InsertColumn(hwndPlayerTable, colCount++, &col);
        }
        else if (isCOD) {
            int actionWidths[] = { 80, 80 };
            col.cx = actionWidths[0]; col.pszText = kickText; ListView_InsertColumn(hwndPlayerTable, colCount++, &col);
            col.cx = actionWidths[1]; col.pszText = banText; ListView_InsertColumn(hwndPlayerTable, colCount++, &col);
        }
        lastGame = server.game;
    }
    else {
        ListView_DeleteAllItems(hwndPlayerTable); // Clear items, preserve columns
    }

    // Validate server details
    if (server.ipOrHostname.empty() || server.port == 0) {
        UIComponents::setOutputMessage(hwnd, "Invalid server details: IP/hostname or port is invalid.");
        return;
    }

    // Query player status
    const char* response = ProcessGameServerCommand(
        server.protocolId,
        false,
        server.ipOrHostname.c_str(),
        server.port,
        "rcon status",
        server.rconPassword.empty() ? "" : server.rconPassword.c_str()
    );

    if (!response || strncmp(response, "error=", 6) == 0) {
        std::string error = response ? response : "No response from server";
        UIComponents::setOutputMessage(hwnd, ("Server may be OFFLINE or changing map: " + error).c_str());
        if (response) FreeGameServerResponse(response);
        return;
    }

    std::string json = response;
    FreeGameServerResponse(response);

    std::vector<std::wstring> strings;
    int index = 0;

    // Parse players array
    size_t playersPos = json.find("\"players\":");
    if (playersPos == std::string::npos) {
        UIComponents::setOutputMessage(hwnd, "Invalid response format");
        return;
    }
    json = json.substr(playersPos + 10);

    // Find the end of the players array, accounting for quoted strings
    size_t arrayEnd = std::string::npos;
    bool inQuotes = false;
    for (size_t i = 0; i < json.length(); ++i) {
        if (json[i] == '"' && (i == 0 || json[i - 1] != '\\')) {
            inQuotes = !inQuotes; // Toggle quote state
        }
        else if (json[i] == ']' && !inQuotes) {
            arrayEnd = i;
            break;
        }
    }
    if (arrayEnd == std::string::npos) {
        UIComponents::setOutputMessage(hwnd, "Invalid response format: Could not find array end");
        return;
    }
    json = json.substr(0, arrayEnd);

    if (json.empty() || json == "[]") {
        return; // No players to display
    }

    // Determine game type for action buttons
    bool isMOHAA = server.game == "Medal of Honor: Allied Assault" || server.game == "Medal of Honor: AA Spearhead";
    bool isMOHSHBT = server.game == "Medal of Honor: AA Breakthrough";
    bool isCOD = server.game.find("Call of Duty") != std::string::npos;

    // Process each player
    size_t start = 0;
    if (json[0] == '[') start = 1; // Skip opening bracket
    while (start < json.length()) {
        size_t objStart = json.find('{', start);
        if (objStart == std::string::npos) break;

        // Find the end of the current player object
        size_t objEnd = std::string::npos;
        int braceCount = 1;
        inQuotes = false;
        for (size_t i = objStart + 1; i < json.length(); ++i) {
            if (json[i] == '"' && (i == 0 || json[i - 1] != '\\')) {
                inQuotes = !inQuotes;
            }
            else if (!inQuotes) {
                if (json[i] == '{') ++braceCount;
                else if (json[i] == '}') {
                    --braceCount;
                    if (braceCount == 0) {
                        objEnd = i;
                        break;
                    }
                }
            }
        }
        if (objEnd == std::string::npos) {
            UIComponents::setOutputMessage(hwnd, "Invalid response format: Malformed player object");
            return;
        }

        std::string playerJson = json.substr(objStart, objEnd - objStart + 1);
        parseAndAddPlayer(hwnd, playerJson, index++, strings, isMOHAA, isMOHSHBT, isCOD);
        start = objEnd + 1;

        // Skip comma or whitespace
        while (start < json.length() && (json[start] == ',' || isspace(json[start]))) ++start;
    }
}

// Parses and adds a player to the player table.
void UIRcon::parseAndAddPlayer(HWND hwnd, std::string playerJson, int index, std::vector<std::wstring>& strings, bool isMOHAA, bool isMOHSHBT, bool isCOD) {
    HWND hwndPlayerTable = GetDlgItem(hwnd, 501);
    if (!hwndPlayerTable) {
        return; // Player table not found
    }

    WCHAR buffer[4096];
    std::string num, name, ip, score, ping;

    // Helper to extract JSON fields
    auto extractField = [](const std::string& json, const std::string& field) {
        size_t pos = json.find("\"" + field + "\":");
        if (pos == std::string::npos) return std::string();
        pos += field.length() + 3;
        if (json[pos] == '"') {
            pos++;
            size_t end = json.find('"', pos);
            return json.substr(pos, end - pos);
        }
        else {
            size_t end = json.find_first_of(",}", pos);
            return json.substr(pos, end - pos);
        }
        };

    // Extract player information
    num = extractField(playerJson, "slot");
    name = extractField(playerJson, "name");
    ip = extractField(playerJson, "address");
    score = extractField(playerJson, "score");
    ping = extractField(playerJson, "ping");

    if (num.empty() || name.empty()) {
        return; // Skip invalid player data
    }

    // Add player to table
    LVITEM item = { 0 };
    item.mask = LVIF_TEXT;
    item.iItem = index;

    MultiByteToWideChar(CP_UTF8, 0, num.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
    strings.emplace_back(buffer);
    item.pszText = (LPWSTR)strings.back().c_str();
    ListView_InsertItem(hwndPlayerTable, &item);

    MultiByteToWideChar(CP_UTF8, 0, name.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
    strings.emplace_back(buffer);
    ListView_SetItemText(hwndPlayerTable, index, 1, (LPWSTR)strings.back().c_str());

    MultiByteToWideChar(CP_UTF8, 0, ip.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
    strings.emplace_back(buffer);
    ListView_SetItemText(hwndPlayerTable, index, 2, (LPWSTR)strings.back().c_str());

    MultiByteToWideChar(CP_UTF8, 0, score.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
    strings.emplace_back(buffer);
    ListView_SetItemText(hwndPlayerTable, index, 3, (LPWSTR)strings.back().c_str());

    MultiByteToWideChar(CP_UTF8, 0, ping.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
    strings.emplace_back(buffer);
    ListView_SetItemText(hwndPlayerTable, index, 4, (LPWSTR)strings.back().c_str());

    // Add game-specific action buttons
    WCHAR renameText[] = L"Rename";
    WCHAR unbindText[] = L"Unbind";
    WCHAR kickText[] = L"Kick";
    WCHAR banText[] = L"Ban";
    int colIndex = 5;
    if (isMOHAA) {
        strings.emplace_back(renameText); ListView_SetItemText(hwndPlayerTable, index, colIndex++, (LPWSTR)strings.back().c_str());
        strings.emplace_back(unbindText); ListView_SetItemText(hwndPlayerTable, index, colIndex++, (LPWSTR)strings.back().c_str());
        strings.emplace_back(kickText); ListView_SetItemText(hwndPlayerTable, index, colIndex, (LPWSTR)strings.back().c_str());
    }
    else if (isMOHSHBT) {
        strings.emplace_back(kickText); ListView_SetItemText(hwndPlayerTable, index, colIndex, (LPWSTR)strings.back().c_str());
    }
    else if (isCOD) {
        strings.emplace_back(kickText); ListView_SetItemText(hwndPlayerTable, index, colIndex++, (LPWSTR)strings.back().c_str());
        strings.emplace_back(banText); ListView_SetItemText(hwndPlayerTable, index, colIndex, (LPWSTR)strings.back().c_str());
    }
} 
--- C:\Projects\xrcon\xRcon\UIServers.cpp --- 
// --- xRcon\UIServers.cpp ---
// Implementation of the server management UI page.
// Provides functionality to create and manage a UI for adding, editing, and displaying game servers.

#include "UIServers.h"
#include "UIComponents.h"
#include <commctrl.h>
#include <vector>
#include <string>

#pragma comment(lib, "comctl32.lib") // Link Common Controls library

// Static UI control handles
static HWND serverTable = nullptr;   // List view for server list
static HWND gameCombo = nullptr;     // Combo box for game selection
static bool serverPageCreated = false; // Flag to track if server page is created

// Creates the server table (list view) to display server information.
void UIServers::createServerTable(HWND hwnd, HINSTANCE hInstance) {
    InitCommonControls(); // Initialize common controls for list view

    // Create server table with report style and single selection
    serverTable = CreateWindow(WC_LISTVIEW, L"", WS_CHILD | LVS_REPORT | LVS_SINGLESEL,
        160, 0, 600, 400, hwnd, (HMENU)200, hInstance, nullptr);

    // Enable full row selection, grid lines, and header drag-drop
    ListView_SetExtendedListViewStyle(serverTable, LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_HEADERDRAGDROP);

    // Initialize table columns
    LVCOLUMN col = { 0 };
    col.mask = LVCF_TEXT | LVCF_WIDTH;

    WCHAR name[] = L"Name";
    WCHAR ip[] = L"IP/Hostname";
    WCHAR port[] = L"Port";
    WCHAR game[] = L"Game";
    WCHAR edit[] = L"Edit";
    WCHAR del[] = L"Delete";

    col.cx = 100; col.pszText = name; ListView_InsertColumn(serverTable, 0, &col);
    col.cx = 150; col.pszText = ip; ListView_InsertColumn(serverTable, 1, &col);
    col.cx = 60; col.pszText = port; ListView_InsertColumn(serverTable, 2, &col);
    col.cx = 150; col.pszText = game; ListView_InsertColumn(serverTable, 3, &col);
    col.cx = 70; col.pszText = edit; ListView_InsertColumn(serverTable, 4, &col);
    col.cx = 70; col.pszText = del; ListView_InsertColumn(serverTable, 5, &col);

    updateServerTable(hwnd); // Populate table with server data
}

// Creates the form for adding or editing server details.
void UIServers::createServerForm(HWND hwnd, HINSTANCE hInstance) {
    // Layout coordinates for form controls
    int x = 770, y = 0, w = 390, h = 25;

    // Create group box for server form
    CreateWindow(L"BUTTON", L"Add Server", WS_CHILD | BS_GROUPBOX,
        x + 20, y + 10, w + 40, 440, hwnd, (HMENU)310, hInstance, nullptr);

    x += 30;
    y += 50;

    // Create server name input
    CreateWindow(L"STATIC", L"Server Name:", WS_CHILD, x, y + 4, 180, h, hwnd, (HMENU)312, hInstance, nullptr);
    CreateWindow(L"EDIT", L"", WS_CHILD | WS_BORDER, x + 130, y, 280, h, hwnd, (HMENU)300, hInstance, nullptr);
    y += 30;

    // Create IP/hostname input
    CreateWindow(L"STATIC", L"IP/Hostname:", WS_CHILD, x, y + 4, 180, h, hwnd, (HMENU)313, hInstance, nullptr);
    CreateWindow(L"EDIT", L"", WS_CHILD | WS_BORDER, x + 130, y, 280, h, hwnd, (HMENU)301, hInstance, nullptr);
    y += 30;

    // Create port input
    CreateWindow(L"STATIC", L"Port:", WS_CHILD, x, y + 4, 180, h, hwnd, (HMENU)314, hInstance, nullptr);
    CreateWindow(L"EDIT", L"", WS_CHILD | WS_BORDER, x + 130, y, 280, h, hwnd, (HMENU)302, hInstance, nullptr);
    y += 30;

    // Create game selection combo box
    CreateWindow(L"STATIC", L"Game:", WS_CHILD, x, y + 4, 180, h, hwnd, (HMENU)315, hInstance, nullptr);
    gameCombo = CreateWindow(WC_COMBOBOX, L"", WS_CHILD | CBS_DROPDOWNLIST | WS_VSCROLL,
        x + 130, y, 280, 200, hwnd, (HMENU)303, hInstance, nullptr);
    y += 30;

    // Create RCON password input
    CreateWindow(L"STATIC", L"RCON Password:", WS_CHILD, x, y + 4, 180, h, hwnd, (HMENU)316, hInstance, nullptr);
    CreateWindow(L"EDIT", L"", WS_CHILD | WS_BORDER, x + 130, y, 280, h, hwnd, (HMENU)304, hInstance, nullptr);
    y += 30;

    // Create gametypes input (multiline)
    CreateWindow(L"STATIC", L"Gametypes:", WS_CHILD, x, y + 4, 180, h, hwnd, (HMENU)317, hInstance, nullptr);
    CreateWindow(L"EDIT", L"", WS_CHILD | WS_BORDER | ES_MULTILINE | ES_AUTOVSCROLL | ES_WANTRETURN | WS_VSCROLL,
        x + 130, y, 280, h * 3, hwnd, (HMENU)305, hInstance, nullptr);
    HWND hwndGametypes = GetDlgItem(hwnd, 305);
    SendMessage(hwndGametypes, EM_SETLIMITTEXT, 4096, 0); // Limit to 4096 characters
    y += 30 * 3;

    // Create maps input (multiline)
    CreateWindow(L"STATIC", L"Maps:", WS_CHILD, x, y + 4, 180, h, hwnd, (HMENU)318, hInstance, nullptr);
    CreateWindow(L"EDIT", L"", WS_CHILD | WS_BORDER | ES_MULTILINE | ES_AUTOVSCROLL | ES_WANTRETURN | WS_VSCROLL,
        x + 130, y, 280, h * 3, hwnd, (HMENU)306, hInstance, nullptr);
    HWND hwndMaps = GetDlgItem(hwnd, 306);
    SendMessage(hwndMaps, EM_SETLIMITTEXT, 4096, 0); // Limit to 4096 characters
    y += 30 * 3;

    // Create save server button
    CreateWindow(L"BUTTON", L"Save Server", WS_CHILD | BS_PUSHBUTTON, x + 310, y, 100, h, hwnd, (HMENU)307, hInstance, nullptr);

    // Populate game combo box with available games
    std::vector<std::wstring> gameStrings;
    auto games = ServerManager::getGameOptions();
    for (const auto& game : games) {
        gameStrings.emplace_back(game.first.begin(), game.first.end());
        SendMessage(gameCombo, CB_ADDSTRING, 0, (LPARAM)gameStrings.back().c_str());
    }
    SendMessage(gameCombo, CB_SETCURSEL, 0, 0); // Select first game

    // Refresh multiline input controls
    UpdateWindow(hwndGametypes);
    UpdateWindow(hwndMaps);
}

// Updates the server table with current server data.
void UIServers::updateServerTable(HWND hwnd) {
    ListView_DeleteAllItems(serverTable); // Clear existing items
    auto servers = ServerManager::loadServers(); // Load server list
    int index = 0;

    std::vector<std::wstring> strings;
    for (const auto& s : servers) {
        WCHAR buffer[4096];
        // Convert server name to wide string
        MultiByteToWideChar(CP_UTF8, 0, s.name.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
        strings.emplace_back(buffer);
        // Convert IP/hostname to wide string
        MultiByteToWideChar(CP_UTF8, 0, s.ipOrHostname.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
        strings.emplace_back(buffer);
        // Convert port to wide string
        strings.emplace_back(std::to_wstring(s.port));
        // Convert game name to wide string
        MultiByteToWideChar(CP_UTF8, 0, s.game.c_str(), -1, buffer, sizeof(buffer) / sizeof(WCHAR));
        strings.emplace_back(buffer);
        strings.emplace_back(L"Edit");
        strings.emplace_back(L"Delete");

        // Add server to table
        LVITEM item = { 0 };
        item.mask = LVIF_TEXT;
        item.iItem = index++;
        item.pszText = (LPWSTR)strings[strings.size() - 6].c_str();
        ListView_InsertItem(serverTable, &item);
        ListView_SetItemText(serverTable, index - 1, 1, (LPWSTR)strings[strings.size() - 5].c_str());
        ListView_SetItemText(serverTable, index - 1, 2, (LPWSTR)strings[strings.size() - 4].c_str());
        ListView_SetItemText(serverTable, index - 1, 3, (LPWSTR)strings[strings.size() - 3].c_str());
        ListView_SetItemText(serverTable, index - 1, 4, (LPWSTR)strings[strings.size() - 2].c_str());
        ListView_SetItemText(serverTable, index - 1, 5, (LPWSTR)strings[strings.size() - 1].c_str());
    }
}

// Creates the server management page by initializing the table and form.
void UIServers::createServerPage(HWND hwnd, HINSTANCE hInstance) {
    if (serverPageCreated) {
        return; // Prevent multiple creations
    }

    createServerTable(hwnd, hInstance); // Create server table
    createServerForm(hwnd, hInstance);  // Create server form
    serverPageCreated = true;
}

// Shows the server page by making all controls visible.
void UIServers::showServerPage(HWND hwnd) {
    if (!serverPageCreated) {
        createServerPage(hwnd, (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE)); // Create page if not exists
    }

    // Show all controls
    ShowWindow(GetDlgItem(hwnd, 200), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 300), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 301), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 302), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 303), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 304), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 305), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 306), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 307), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 310), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 312), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 313), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 314), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 315), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 316), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 317), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 318), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, 400), SW_SHOW); 
    InvalidateRect(hwnd, nullptr, TRUE); // Redraw window
    UpdateWindow(hwnd);
}

// Hides the server page (currently a no-op if page is created).
void UIServers::hideServerPage(HWND hwnd) {
    if (serverPageCreated) {
        // No controls are hidden (placeholder for future use)
    }
} 
--- C:\Projects\xrcon\xRcon\Resource.rc --- 
#include "resource.h"
IDI_ICON1 ICON "aa.ico" 
--- C:\Projects\xrcon\xRcon\README.md --- 
ï»¿ 
